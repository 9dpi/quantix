import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
import pg from 'pg';
import { createClient } from '@supabase/supabase-js';
// Native fetch used

dotenv.config();

// Initialize Supabase for SSOT data access
const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_KEY
);

// --- CONFIGURATION ---
const TOKEN = process.env.TELEGRAM_BOT_TOKEN || process.env.TELEGRAM_TOKEN;
if (!TOKEN) {
    console.error("âŒ [CRITICAL] No TELEGRAM_BOT_TOKEN found in environment variables!");
    process.exit(1);
}
const TELEGRAM_API = `https://api.telegram.org/bot${TOKEN}`;

// Group IDs from Railway Variables
const COMMUNITY_GROUP = process.env.GROUP_ID_COMMUNITY || '';
const VIP_GROUP = process.env.GROUP_ID_VIP || '';
const OFFICIAL_GROUP = process.env.GROUP_ID_OFFICIAL || '';

const { Pool } = pg;
const pool = new Pool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    port: parseInt(process.env.DB_PORT || '5432'),
    ssl: { rejectUnauthorized: false }
});

// --- PATTERN CACHE LOADING ---
let patternCache = [];

// --- ADMIN BACKTEST ENGINE V1.9.5 ---
// State management for 2FA backtest authentication
const backtestStates = new Map();
const ADMIN_PASSCODE = '9119';

/**
 * Calculate real pips based on symbol type
 * Gold/XAU: diff * 10
 * Forex: diff / 0.0001
 */
function getRealPips(symbol, entry, exit) {
    const diff = Math.abs(entry - exit);
    if (symbol.includes('XAUUSD') || symbol.includes('GOLD') || symbol.includes('XAU')) {
        return diff * 10;
    }
    // Forex pairs (EURUSD, GBPUSD, etc.)
    return diff / 0.0001;
}
const CACHE_MODE = process.env.PATTERN_CACHE_MODE || 'LOCAL';

async function loadPatterns() {
    try {
        if (CACHE_MODE === 'CLOUD') {
            console.log('[V1.9] Loading patterns from Cloud (Supabase)...');
            const result = await pool.query('SELECT vector_hash, results FROM pattern_cache LIMIT 5000');
            patternCache = result.rows;
            console.log(`[V1.9] Loaded ${patternCache.length} patterns from Cloud.`);
        } else {
            loadLocalPatterns();
        }
    } catch (err) {
        console.warn('[V1.9] Pattern loading delayed or failed, using empty cache.', err.message);
    }
}

function loadLocalPatterns() {
    const PATTERN_PATH = path.join('RecoveryVault', 'patterns_backup_v1.9.json');
    try {
        if (fs.existsSync(PATTERN_PATH)) {
            patternCache = JSON.parse(fs.readFileSync(PATTERN_PATH, 'utf8'));
            console.log(`[V1.9] Loaded ${patternCache.length} patterns from local backup.`);
        }
    } catch (err) {
        console.error(`[V1.9] Local load error:`, err.message);
    }
}

loadPatterns();

// --- TELEGRAM API WRAPPER ---
async function botAction(method, body) {
    try {
        const response = await fetch(`${TELEGRAM_API}/${method}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        if (!data.ok) {
            console.error(`[BOT API Error] ${method} failed:`, data.description);
        }
        return data;
    } catch (e) {
        console.error(`[BOT Network Error] ${method} failed:`, e.message);
        return { ok: false, error: e.message };
    }
}

// --- LOGIC HELPERS ---
/**
 * SSOT DATA ACCESS: Get asset data from market_snapshot table
 * This replaces all Yahoo Finance API calls
 */
async function getAssetSnapshot(symbol) {
    try {
        const { data, error } = await supabase
            .from('market_snapshot')
            .select('*')
            .eq('symbol', symbol)
            .single();

        if (error || !data) {
            console.error(`ðŸš¨ [BOT_ERROR] Cannot read snapshot for ${symbol}:`, error?.message);
            return null;
        }

        // Calculate data freshness
        const lastUpdated = new Date(data.last_updated);
        const ageSeconds = (Date.now() - lastUpdated.getTime()) / 1000;

        if (ageSeconds > 300) { // 5 minutes
            console.warn(`âš ï¸ [BOT_WARNING] Stale data for ${symbol}: ${Math.round(ageSeconds)}s old`);
        }

        console.log(`âœ… [SSOT_READ] ${symbol}: $${data.price} | ${data.ai_status} (${data.confidence_score}%) | Age: ${Math.round(ageSeconds)}s`);
        return data;
    } catch (err) {
        console.error(`ðŸš¨ [BOT_CRITICAL] SSOT read failed for ${symbol}:`, err.message);
        return null;
    }
}

function normalizeCandles(candles) {
    const base = candles[0].o || candles[0].open;
    return candles.map(c => ({
        o: ((c.o || c.open) - base) / base,
        h: ((c.h || c.high) - base) / base,
        l: ((c.l || c.low) - base) / base,
        c: ((c.c || c.close) - base) / base
    }));
}

function calculateCorrelation(current, target) {
    const normCurrent = normalizeCandles(current);
    const normTarget = normalizeCandles(target);
    let sumSqDiff = 0;
    for (let i = 0; i < 4; i++) {
        ['o', 'h', 'l', 'c'].forEach(f => {
            sumSqDiff += Math.pow(normCurrent[i][f] - normTarget[i][f], 2);
        });
    }
    return Math.max(0, 100 * (1 - (Math.sqrt(sumSqDiff) * 10)));
}

function findBestMatch(currentCandles) {
    let bestMatch = null;
    let maxCorrelation = 0;
    for (const p of patternCache) {
        if (!p.results || !p.results.candles) continue;
        const correlation = calculateCorrelation(currentCandles, p.results.candles);
        if (correlation > maxCorrelation) {
            maxCorrelation = correlation;
            bestMatch = p;
        }
    }
    return { bestMatch, correlation: maxCorrelation };
}

// --- MESSAGE HANDLER ---
async function handleMessage(msg) {
    const text = msg.text;
    const chatId = msg.chat.id.toString();
    const isPrivate = msg.chat.type === 'private';

    console.log(`ðŸ“© [INCOMING] Message from ${chatId} (${isPrivate ? 'Private' : 'Group'}): "${text || '[No Text]'}"`);

    if (!text) return;

    // 0. GLOBAL COMMAND: /start
    if (text === '/start') {
        const welcome = `ðŸš€ **Quantix Bot v1.9.5 - ONLINE**\n\nI have received your message. AI Core is active.\n\nType **/vip** to see my latest analysis!\nType **/backtest** for admin performance audit.`;
        return await botAction('sendMessage', { chat_id: chatId, text: welcome, parse_mode: 'Markdown' });
    }

    // ðŸ” ADMIN BACKTEST ENGINE V1.9.5 - STAGE 1: INITIATE 2FA
    if (text === '/backtest') {
        backtestStates.set(chatId, { status: 'AWAITING_PASSCODE', timestamp: Date.now() });
        console.log(`ðŸ” [BACKTEST] 2FA challenge initiated for ${chatId}`);
        return await botAction('sendMessage', {
            chat_id: chatId,
            text: `ðŸ” **QUANTIX SECURITY CHALLENGE**\n\nThis command requires admin authorization.\n\nPlease input the passcode:`,
            parse_mode: 'Markdown'
        });
    }

    // ðŸ” ADMIN BACKTEST ENGINE V1.9.5 - STAGE 2 & 3: VERIFY & EXECUTE
    const backtestState = backtestStates.get(chatId);
    if (backtestState && backtestState.status === 'AWAITING_PASSCODE') {
        // Check timeout (5 minutes)
        if (Date.now() - backtestState.timestamp > 300000) {
            backtestStates.delete(chatId);
            return await botAction('sendMessage', {
                chat_id: chatId,
                text: 'â±ï¸ **Session Expired**\n\nPlease restart with /backtest'
            });
        }

        // Verify passcode
        if (text === ADMIN_PASSCODE) {
            backtestStates.delete(chatId);
            console.log(`âœ… [BACKTEST] Access granted for ${chatId}`);

            await botAction('sendMessage', {
                chat_id: chatId,
                text: 'âœ… **Access Granted**\n\nCalculating real-data performance...'
            });

            try {
                // Query real signals from last 24 hours
                const { data: signals, error } = await supabase
                    .from('ai_signals')
                    .select('*')
                    .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

                if (error) throw error;

                // Calculate performance metrics
                let results = {
                    win: 0,
                    loss: 0,
                    open: 0,
                    totalPips: 0,
                    grossProfit: 0,
                    grossLoss: 0,
                    highConfWins: 0,
                    signals: []
                };

                signals.forEach(s => {
                    const entry = s.entry_price || s.predicted_close;
                    const exit = s.current_price || s.tp1_price || s.tp2_price;

                    if (!entry || !exit) {
                        results.open++;
                        return;
                    }

                    const pips = getRealPips(s.symbol, entry, exit);

                    if (s.signal_status === 'TP1_HIT' || s.signal_status === 'TP2_HIT' || s.signal_status === 'target_reached') {
                        results.win++;
                        results.totalPips += pips;
                        results.grossProfit += pips;
                        if (s.confidence_score >= 90) results.highConfWins++;
                        results.signals.push({ symbol: s.symbol, pips: pips.toFixed(1), result: 'WIN' });
                    } else if (s.signal_status === 'SL_HIT' || s.signal_status === 'failed') {
                        results.loss++;
                        results.totalPips -= pips;
                        results.grossLoss += pips;
                        results.signals.push({ symbol: s.symbol, pips: -pips.toFixed(1), result: 'LOSS' });
                    } else {
                        results.open++;
                    }
                });

                // Calculate win rate
                const totalClosed = results.win + results.loss;
                const winRate = totalClosed > 0 ? ((results.win / totalClosed) * 100).toFixed(1) : 0;

                // Generate report
                const report = `
ðŸ† **QUANTIX 24H PERFORMANCE AUDIT**
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“Š **Signal Summary**:
âœ… Wins: ${results.win}
âŒ Losses: ${results.loss}
â³ Open: ${results.open}
ðŸ“ˆ Win Rate: ${winRate}%

ðŸ’° **P&L Analysis**:
ðŸ’µ Gross Profit: +${results.grossProfit.toFixed(1)} pips
ðŸ’¸ Gross Loss: -${results.grossLoss.toFixed(1)} pips
ðŸ’Ž **NET P&L: ${results.totalPips >= 0 ? '+' : ''}${results.totalPips.toFixed(1)} pips**

ðŸ§  **AI Performance**:
ðŸŽ¯ High Confidence Wins (â‰¥90%): ${results.highConfWins}

ðŸ“‹ **Recent Signals**:
${results.signals.slice(-5).map(s => `${s.result === 'WIN' ? 'âœ…' : 'âŒ'} ${s.symbol}: ${s.pips} pips`).join('\n') || 'No closed signals yet'}

ðŸ•’ **Data Source**: Real signals from ai_signals table
â° **Period**: Last 24 hours
ðŸ›¡ï¸ **Verified by**: Quantix SSOT v1.9.5
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                `;

                await botAction('sendMessage', {
                    chat_id: chatId,
                    text: report,
                    parse_mode: 'Markdown'
                });

                console.log(`ðŸ“Š [BACKTEST] Report sent to ${chatId}: ${results.win}W/${results.loss}L, ${results.totalPips.toFixed(1)} pips`);

            } catch (error) {
                console.error('[BACKTEST ERROR]', error);
                await botAction('sendMessage', {
                    chat_id: chatId,
                    text: 'âŒ **Error calculating performance**\n\nPlease contact admin.'
                });
            }
        } else {
            // Invalid passcode
            backtestStates.delete(chatId);
            console.log(`âŒ [BACKTEST] Invalid passcode attempt from ${chatId}`);
            return await botAction('sendMessage', {
                chat_id: chatId,
                text: 'âŒ **Access Denied**\n\nInvalid passcode.'
            });
        }
        return; // Exit after handling backtest flow
    }

    // A. VIP EXPERIENCE (Showcase /vip)
    if (text === '/vip' || chatId === VIP_GROUP) {
        try {
            // ðŸ”¥ SSOT: Read from market_snapshot instead of Yahoo Finance
            const snapshot = await getAssetSnapshot('EURUSD=X');

            // Fetch latest VIP signal from Quantix AI Core (confidence >95%)
            const result = await pool.query(`
                SELECT 
                    symbol,
                    signal_type,
                    predicted_close as entry_price,
                    tp1_price,
                    sl_price,
                    confidence_score,
                    created_at
                FROM ai_signals 
                WHERE confidence_score > 95
                AND is_published = TRUE
                ORDER BY created_at DESC 
                LIMIT 1
            `);

            if (result.rows.length === 0) {
                await botAction('sendMessage', {
                    chat_id: chatId,
                    text: "â³ No VIP signals available yet. Quantix AI Core is scanning for >95% confidence setups."
                });
                return;
            }

            const signal = result.rows[0];
            const pair = signal.symbol.replace('=X', '');
            const action = signal.signal_type === 'LONG' ? 'BUY' : 'SELL';
            const tradeType = action === 'BUY' ? 'BUY (Long)' : 'SELL (Short)';

            const entry = parseFloat(signal.entry_price);
            const tp = parseFloat(signal.tp1_price || (entry * (action === 'BUY' ? 1.004 : 0.996)));
            const sl = parseFloat(signal.sl_price || (entry * (action === 'BUY' ? 0.997 : 1.003)));

            const pipValue = 0.0001;
            const targetPips = Math.abs((tp - entry) / pipValue).toFixed(0);
            const stopPips = Math.abs((entry - sl) / pipValue).toFixed(0);
            const riskReward = (targetPips / stopPips).toFixed(2);

            const entryLow = (entry - 2 * pipValue).toFixed(5);
            const entryHigh = (entry + 2 * pipValue).toFixed(5);

            // Format timestamp
            const signalDate = new Date(signal.created_at);
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = monthNames[signalDate.getUTCMonth()];
            const day = signalDate.getUTCDate();
            const year = signalDate.getUTCFullYear();
            const hours = String(signalDate.getUTCHours()).padStart(2, '0');
            const minutes = String(signalDate.getUTCMinutes()).padStart(2, '0');
            const utcTime = `${month} ${day}, ${year} â€” ${hours}:${minutes} UTC`;

            const response = `
ðŸ“Š Asset: ${pair}
ðŸ“Œ Trade: ${tradeType}

ðŸ“ˆ Charts:
* Bias: H1
* Entry: M5â€“M15

ðŸ’° Price Levels:
Entry Zone: ${entryLow} â€“ ${entryHigh}
Take Profit (TP): ${tp.toFixed(5)}
Stop Loss (SL): ${sl.toFixed(5)}

ðŸ“ Risk Management:
* Target: +${targetPips} pips
* Stop: âˆ’${stopPips} pips
* Risk:Reward: 1:${riskReward}
* Suggested Risk: 0.5%â€“1% per trade

ðŸ§  AI Confidence: ${signal.confidence_score}% (model conviction score)
ðŸ•’ Trade Type: Intraday
â° Posted: ${utcTime}

âš ï¸ Not financial advice. Trade responsibly.
            `.trim();

            const keyboard = {
                inline_keyboard: [[{ text: 'ðŸ“Š Live Dashboard', url: 'https://9dpi.github.io/ai-forecast-demo/#/mvp' }]]
            };

            await botAction('sendMessage', {
                chat_id: chatId,
                text: response,
                reply_markup: keyboard
            });
        } catch (e) {
            console.error('[VIP ERROR]', e);
            await botAction('sendMessage', { chat_id: chatId, text: `âŒ Error fetching VIP signal. Please try again.` });
        }
    }

    // B. OFFICIAL EXPERIENCE (Transparency /status)
    else if (text === '/status' || chatId === OFFICIAL_GROUP) {
        try {
            const stats = await pool.query(`
                SELECT 
                    COUNT(*) FILTER (WHERE signal_status IN ('TP1_HIT', 'TP2_HIT')) as win,
                    COUNT(*) FILTER (WHERE signal_status = 'SL_HIT') as loss
                FROM ai_signals 
                WHERE created_at > NOW() - INTERVAL '24 hours'
            `);

            const activeTrades = await pool.query(`
                SELECT symbol, signal_type, entry_price, current_price 
                FROM ai_signals 
                WHERE signal_status IN ('ENTRY_HIT', 'WAITING') 
                AND is_published = TRUE
                ORDER BY created_at DESC LIMIT 3
            `);

            const { win, loss } = stats.rows[0];
            const pips = ((win * 25) - (loss * 15)).toFixed(0);

            let activeText = "";
            if (activeTrades.rows.length > 0) {
                activeTrades.rows.forEach(t => {
                    const diff = t.signal_type === 'BUY' ? (t.current_price - t.entry_price) : (t.entry_price - t.current_price);
                    const pipsMove = (diff * 10000).toFixed(1);
                    activeText += `\nâ€¢ ${t.symbol}: \`${pipsMove > 0 ? '+' : ''}${pipsMove} pips\` (${t.signal_type})`;
                });
            } else {
                activeText = "\n*Currently no active signals.*";
            }

            const message = `
ðŸ“Š **SIGNAL GENIUS â€” OFFICIAL REPORT**
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“ˆ **Daily Performance (24h)**:
- Results: \`${win} Win - ${loss} Loss\`
- Net Profit: \`+${pips} pips\` âœ…

âŒ› **Running Trades**:
${activeText}

âœ¨ *Status: All systems operational.*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                `;

            await botAction('sendMessage', { chat_id: chatId, text: message, parse_mode: 'Markdown' });
        } catch (err) {
            await botAction('sendMessage', { chat_id: chatId, text: "âŒ System syncing... retry in 1m." });
        }
    }

    // C. COMMUNITY & PRIVATE DMs (Funnel - Any key)
    else if (chatId === COMMUNITY_GROUP || isPrivate) {
        if (!text.startsWith('/')) {
            const teaser = `
âœ¨ **SIGNAL GENIUS COMMUNITY**

ðŸ”¥ AI v1.9 just detected a high-probability pattern on **EUR/USD**!
- **Historical Accuracy**: \`82.4%\`
- **Expected Move**: \`+35 pips\`

ðŸ”“ **Unlock full details & entry levels now:**
ðŸ‘‰ [Upgrade to VIP Now](http://signalgeniusai.com)

*AI-Powered Intelligence at your fingertips.*
            `;
            await botAction('sendMessage', { chat_id: chatId, text: teaser, parse_mode: 'Markdown' });
        }
    }
}

// --- POLLING ---
let lastUpdateId = 0;

async function initBot() {
    console.log('ðŸ›¡ï¸ [INIT] Bot startup sequence initiated...');
    console.log(`ðŸ›¡ï¸ [INIT] Using Token starting with: ${TOKEN.substring(0, 5)}... (Length: ${TOKEN.length})`);

    try {
        console.log('ðŸ›¡ï¸ [INIT] Attempting to clear Telegram Webhook...');
        const delRes = await botAction('deleteWebhook', { drop_pending_updates: true });
        console.log('ðŸ›¡ï¸ [INIT] Webhook deletion result:', JSON.stringify(delRes));
    } catch (err) {
        console.error('ðŸ›¡ï¸ [INIT] Webhook deletion FAILED (non-critical):', err.message);
    }

    console.log('ðŸš€ [INIT] Polling loop STARTING NOW...');
    pollUpdates();

    setInterval(() => {
        console.log(`ðŸ’“ [HEARTBEAT] Bot v1.9.3 is active. Last Update ID: ${lastUpdateId}`);
    }, 60000);
}

async function pollUpdates() {
    try {
        const data = await botAction('getUpdates', { offset: lastUpdateId + 1, timeout: 20 });
        if (data && data.ok && data.result && data.result.length > 0) {
            for (const update of data.result) {
                lastUpdateId = update.update_id;
                if (update.message) {
                    try {
                        await handleMessage(update.message);
                    } catch (msgErr) {
                        console.error('[HANDLER ERROR]', msgErr.message);
                    }
                }
            }
        }
    } catch (e) {
        console.error('[POLLING CRITICAL ERROR]:', e.message);
    }
    // High-frequency polling backoff
    setTimeout(pollUpdates, 500);
}

initBot();
console.log(`ðŸš€ [PRODUCTION] Telegram Bot v1.9.4 - SSOT CONSUMER MODE`);
console.log(`ðŸ“– Reading from: market_snapshot table (SSOT)`);
console.log(`- Community Group: ${COMMUNITY_GROUP}`);
console.log(`- VIP Group: ${VIP_GROUP}`);
console.log(`- Official Group: ${OFFICIAL_GROUP}`);
